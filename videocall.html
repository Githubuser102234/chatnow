<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>ðŸ“ž Video Call</title>
  <style>
    body { font-family: sans-serif; text-align: center; margin: 1em; }
    video { width: 45%; margin: 1%; background: #000; }
    #callUI { display: none; }
    #linkContainer { margin: 1em 0; }
    #status {
      font-weight: bold;
      color: white;
      background: #444;
      padding: 5px 10px;
      border-radius: 5px;
      display: inline-block;
      margin: 10px auto;
    }
  </style>
</head>
<body>

  <h1>Video Call with Supabase</h1>
  <div id="status">Not connected</div>

  <div id="startUI">
    <button id="createBtn">Create Call</button>
    <p>Or open this page with a #call_id link to join a call.</p>
  </div>

  <div id="linkContainer">
    Share this link:<br>
    <code id="shareLink" style="word-break: break-all;"></code>
  </div>

  <div id="callUI">
    <video id="localVideo" autoplay muted playsinline></video>
    <video id="remoteVideo" autoplay playsinline></video>
  </div>

  <script type="module">
    import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js/+esm'

    const SUPABASE_URL = 'https://ahsrsrkzmphbhecishuc.supabase.co'
    const SUPABASE_ANON = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImFoc3Jzcmt6bXBoYmhlY2lzaHVjIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTE3NjEwODAsImV4cCI6MjA2NzMzNzA4MH0.CI0EQak2VQJi883JkdtD01XQpvKq8lfXoq4PsvGiapA'

    const supabase = createClient(SUPABASE_URL, SUPABASE_ANON)

    const startUI = document.getElementById('startUI')
    const createBtn = document.getElementById('createBtn')
    const shareLink = document.getElementById('shareLink')
    const callUI = document.getElementById('callUI')
    const localVid = document.getElementById('localVideo')
    const remoteVid = document.getElementById('remoteVideo')
    const statusEl = document.getElementById('status')

    let pc
    let callId
    let role
    let remoteDescriptionSet = false
    let pendingCandidates = []

    createBtn.onclick = createCall

    function uuid4() {
      return ([1e7]+-1e3+-4e3+-8e3+-1e11)
        .replace(/[018]/g, c =>
          (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
        );
    }

    async function createCall() {
      callId = uuid4()
      const { error } = await supabase.from('calls').insert([{ call_id: callId }])
      if (error) {
        alert('Error creating call: ' + error.message)
        return
      }
      location.hash = callId
      shareLink.textContent = location.href
      startUI.style.display = 'none'
      callUI.style.display = 'block'
      role = 'caller'
      startWebRTC()
    }

    async function joinCall(id) {
      callId = id
      shareLink.textContent = location.href
      startUI.style.display = 'none'
      callUI.style.display = 'block'
      role = 'callee'
      startWebRTC()
    }

    async function startWebRTC() {
      setStatus('Connecting...')

      pc = new RTCPeerConnection({
        iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
      })

      const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true })
      localVid.srcObject = stream
      stream.getTracks().forEach(track => pc.addTrack(track, stream))

      pc.ontrack = event => {
        if (!remoteVid.srcObject) {
          remoteVid.srcObject = new MediaStream()
        }
        remoteVid.srcObject.addTrack(event.track)
        setStatus('Connected')
      }

      pc.onicecandidate = async ({ candidate }) => {
        if (candidate) {
          await supabase.from('signaling').insert([{
            call_id: callId,
            sender: role,
            signal_type: 'ice',
            payload: candidate.toJSON()
          }])
        }
      }

      pc.onconnectionstatechange = () => {
        if (pc.connectionState === 'connected') {
          setStatus('Connected')
        } else if (pc.connectionState === 'disconnected' || pc.connectionState === 'failed') {
          setStatus('Disconnected')
        }
      }

      supabase
        .channel('signaling_channel')
        .on('postgres_changes', { event: 'INSERT', schema: 'public', table: 'signaling', filter: `call_id=eq.${callId}` }, payload => {
          onSignal(payload.new)
        })
        .subscribe()

      if (role === 'caller') {
        const offer = await pc.createOffer()
        await pc.setLocalDescription(offer)
        await supabase.from('signaling').insert([{
          call_id: callId,
          sender: role,
          signal_type: 'offer',
          payload: offer.toJSON()
        }])
      }
    }

    async function onSignal(msg) {
      if (msg.sender === role) return

      switch (msg.signal_type) {
        case 'offer':
          await pc.setRemoteDescription(new RTCSessionDescription(msg.payload))
          remoteDescriptionSet = true
          const answer = await pc.createAnswer()
          await pc.setLocalDescription(answer)
          await supabase.from('signaling').insert([{
            call_id: callId,
            sender: role,
            signal_type: 'answer',
            payload: answer.toJSON()
          }])
          flushPendingCandidates()
          break

        case 'answer':
          await pc.setRemoteDescription(new RTCSessionDescription(msg.payload))
          remoteDescriptionSet = true
          flushPendingCandidates()
          break

        case 'ice':
          if (remoteDescriptionSet) {
            try {
              await pc.addIceCandidate(new RTCIceCandidate(msg.payload))
            } catch (e) {
              console.warn('Error adding ICE candidate:', e)
            }
          } else {
            pendingCandidates.push(msg.payload)
          }
          break
      }
    }

    async function flushPendingCandidates() {
      for (const c of pendingCandidates) {
        try {
          await pc.addIceCandidate(new RTCIceCandidate(c))
        } catch (e) {
          console.warn('Failed to flush ICE candidate:', e)
        }
      }
      pendingCandidates = []
    }

    function setStatus(text) {
      statusEl.textContent = text
      statusEl.style.background = {
        'Connected': '#4caf50',
        'Disconnected': '#f44336',
        'Connecting...': '#ff9800'
      }[text] || '#444'
    }

    window.onload = () => {
      const hash = location.hash.slice(1)
      if (hash) {
        joinCall(hash)
      }
    }
  </script>

</body>
</html>